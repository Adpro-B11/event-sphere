package id.ac.ui.cs.advprog.eventsphere.reviewrating.repository;

import id.ac.ui.cs.advprog.eventsphere.reviewrating.model.Review;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;

import java.time.ZonedDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest
class ReviewRepositoryTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private ReviewRepository reviewRepository;

    private Review testReview1;
    private Review testReview2;
    private final String eventId1 = "evt_" + UUID.randomUUID().toString().substring(0, 8);
    private final String userId1 = "usr_" + UUID.randomUUID().toString().substring(0, 8);
    private final String username1 = "John Doe";
    private final String eventId2 = "evt_" + UUID.randomUUID().toString().substring(0, 8);
    private final String userId2 = "usr_" + UUID.randomUUID().toString().substring(0, 8);
    private final String username2 = "Jane Smith";

    @BeforeEach
    void setUp() {
        reviewRepository.deleteAll(); // Clear repository before each test

        testReview1 = new Review();
        testReview1.setRating(4);
        testReview1.setComment("Good event");
        testReview1.setCreatedAt(ZonedDateTime.now());
        testReview1.setUserId(userId1);
        testReview1.setUsername(username1);
        testReview1.setEventId(eventId1);
        entityManager.persist(testReview1); // Use TestEntityManager to save

        testReview2 = new Review();
        testReview2.setRating(5);
        testReview2.setComment("Excellent event!");
        testReview2.setCreatedAt(ZonedDateTime.now().minusDays(1));
        testReview2.setUserId(userId2);
        testReview2.setUsername(username2); 
        testReview2.setEventId(eventId1);
        entityManager.persist(testReview2);

        entityManager.flush(); // Ensure data is persisted before queries
    }

    @Test
    void testSaveAndFindById() {
        Review newReview = new Review();
        newReview.setRating(3);
        newReview.setComment("Okay event");
        newReview.setCreatedAt(ZonedDateTime.now());
        newReview.setUserId("usr_new");
        newReview.setUsername("New User");
        newReview.setEventId("evt_new");

        Review savedReview = reviewRepository.save(newReview);
        assertNotNull(savedReview.getId(), "ID should be generated by JPA");

        Optional<Review> found = reviewRepository.findById(savedReview.getId());
        assertTrue(found.isPresent());
        assertEquals(savedReview.getId(), found.get().getId());
        assertEquals(3, found.get().getRating());
        assertEquals("New User", found.get().getUsername()); 
    }

    @Test
    void testFindById_NotFound() {
        Optional<Review> found = reviewRepository.findById("non_existent_id");
        assertFalse(found.isPresent());
    }

    @Test
    void testFindByEventId() {
        List<Review> eventReviews = reviewRepository.findByEventId(eventId1);
        assertEquals(2, eventReviews.size());
        assertTrue(eventReviews.stream().anyMatch(r -> r.getComment().equals("Good event")));
        assertTrue(eventReviews.stream().anyMatch(r -> r.getComment().equals("Excellent event!")));
        
        assertTrue(eventReviews.stream().anyMatch(r -> r.getUsername().equals(username1)));
        assertTrue(eventReviews.stream().anyMatch(r -> r.getUsername().equals(username2)));
    }

    @Test
    void testFindByEventId_NotFound() {
        List<Review> eventReviews = reviewRepository.findByEventId("non_existent_event_id");
        assertTrue(eventReviews.isEmpty());
    }

    @Test
    void testFindByUserIdAndEventId() {
        Optional<Review> found = reviewRepository.findByUserIdAndEventId(userId1, eventId1);
        assertTrue(found.isPresent());
        assertEquals(testReview1.getId(), found.get().getId());
        assertEquals(4, found.get().getRating());
        assertEquals(username1, found.get().getUsername()); // ADDED: Check username
    }

    @Test
    void testFindByUserIdAndEventId_NotFound() {
        Optional<Review> found = reviewRepository.findByUserIdAndEventId(userId1, "non_existent_event_id");
        assertFalse(found.isPresent());

        Optional<Review> found2 = reviewRepository.findByUserIdAndEventId("non_existent_user_id", eventId1);
        assertFalse(found2.isPresent());
    }

    @Test
    void testDelete() {
        assertNotNull(testReview1.getId());
        reviewRepository.deleteById(testReview1.getId());
        entityManager.flush(); // Ensure delete is processed

        Optional<Review> found = reviewRepository.findById(testReview1.getId());
        assertFalse(found.isPresent());
    }

    @Test
    void testUpdateReview() {
        Optional<Review> reviewOptional = reviewRepository.findById(testReview1.getId());
        assertTrue(reviewOptional.isPresent());
        Review reviewToUpdate = reviewOptional.get();

        reviewToUpdate.setComment("Updated Comment");
        reviewToUpdate.setRating(1);
        reviewToUpdate.setUsername("Updated Username"); // ADDED: Update username
        reviewToUpdate.setUpdatedAt(ZonedDateTime.now());
        reviewRepository.save(reviewToUpdate);
        entityManager.flush();

        Optional<Review> updatedReviewOptional = reviewRepository.findById(testReview1.getId());
        assertTrue(updatedReviewOptional.isPresent());
        assertEquals("Updated Comment", updatedReviewOptional.get().getComment());
        assertEquals(1, updatedReviewOptional.get().getRating());
        assertEquals("Updated Username", updatedReviewOptional.get().getUsername());
        assertNotNull(updatedReviewOptional.get().getUpdatedAt());
    }

    @Test
    void testUsernameConstraint() {
        // Test that username is required (cannot be null)
        Review invalidReview = new Review();
        invalidReview.setRating(5);
        invalidReview.setComment("Test comment");
        invalidReview.setCreatedAt(ZonedDateTime.now());
        invalidReview.setUserId("usr_test");
        invalidReview.setEventId("evt_test");
        // Note: Not setting username

        assertThrows(Exception.class, () -> {
            reviewRepository.save(invalidReview);
            entityManager.flush();
        }, "Should throw exception when username is null");
    }

    @Test
    void testUniqueConstraintUserIdAndEventId() {
        // Test that a user cannot review the same event twice
        Review duplicateReview = new Review();
        duplicateReview.setRating(3);
        duplicateReview.setComment("Duplicate review");
        duplicateReview.setCreatedAt(ZonedDateTime.now());
        duplicateReview.setUserId(userId1); // Same userId as testReview1
        duplicateReview.setUsername("Duplicate User");
        duplicateReview.setEventId(eventId1); // Same eventId as testReview1

        assertThrows(Exception.class, () -> {
            reviewRepository.save(duplicateReview);
            entityManager.flush();
        }, "Should throw constraint violation exception for duplicate userId-eventId combination");
    }
}